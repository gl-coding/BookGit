# 第1节：网页前端

# 3.1.网页前端

3.1.1.amis

一种页面渲染器，可以直接基于特定格式的JSON配置将页面渲染出来，结合业务方API可快速完成各类管理页面的开发。 

目前用于百度内部AMIS平台，已有100+部门接入使用，创建1.2w +页面，欢迎大家使用和提建议。

通过amis搭建自己的后台系统，可以参考这：https://github.com/fex-team/amis-admin

AMIS是做啥的

完全基于 JSON 的 mis 工具,，不需要前端就可以自己搭建信息管理系统，比如监控啊管理啊之类的，这是能让前端失业的一个框架。

这个截图所有的元素, 都由json控制, 不需要任何前端代码，十足的后端福利。

大概看下基本用法中的例子：

 

为了简化前端开发，amis Renderer 能够直接用配置就能将页面渲染出来。

 

先来看个简单的例子。

 

{

"$schema": "https://houtai.baidu.com/v2/schemas/page.json#",

"type": "page",

"title": "这是标题部分",

"subTitle": "这是子标题",

"remark": "这是小提示信息",

"aside": "这是侧边栏部分",

"body": "这是内容区",

"toolbar": "这是工具栏部分"

}

 

PS: 可以通过编辑器实时修改预览

 

从上面的内容可以看出，一个简单页面框架已经基本出来了，这是 amis 渲染器配置的入口。从 page 渲染器开始出发，通过在容器中放置不同的渲染器来配置不同性质的页面。

 

简单说明以上配置信息。

 

$schema 这个字段可以忽略，他是指定当前 JSON 配置是符合指定路径 https://houtai.baidu.com/v2/schemas/page.json 的 JSON SCHEMA 文件描述的。PS: 编辑器就是靠这个描述文件提示的，可以 hover 到字段上看效果。

 

type 指定渲染器类型，这里指定的类型为 page。更多渲染器类型可以去这里面查看。

 

title 从 title 开始就是对应的渲染模型上的属性了。这里用来指定标题内容。

 

subTitle 副标题.

 

remark 标题上面的提示信息

 

aside 边栏区域内容

 

body 内容区域的内容

 

toolbar 工具栏部分的内容

 

这里有三个配置都是容器类型的。aside、body 和 toolbar。

 

 

 

什么是容器类型？

 

 

 

容器类型表示，他能够把其他渲染类型放进来。以上的例子为了简单，直接放了个字符串。

 

 

 

字符串类型内部是把他当成了 tpl 渲染器来处理，在这里也可以通过对象的形式指定，如以下的例子的 body 区域是完全等价的。

 

{

"$schema": "https://houtai.baidu.com/v2/schemas/page.json",

"type": "page",

"body": {

"type": "tpl",

"tpl": "这是内容区"

}

}

 

容器内可以直接放一个渲染器，也可以放多个，用数组包起来即可如：

 

{

"$schema": "https://houtai.baidu.com/v2/schemas/page.json",

"type": "page",

"body": [

{

"type": "tpl",

"tpl": "<p>段落1</p>"

},

 

{

"type": "tpl",

"tpl": "<p>段落2</p>"

},

 

"<p>段落3</p>"

]

}

 

再来看一个表单页面的列子

 

{

"$schema": "https://houtai.baidu.com/v2/schemas/page.json#",

"type": "page",

"body": {

"api": "/api/mock2/form/saveForm",

"type": "form",

"title": "联系我们",

"controls": [

{

"type": "text",

"label": "姓名",

"name": "name"

},

 

{

"type": "email",

"label": "邮箱",

"name": "email",

"required": true

},

 

{

"type": "textarea",

"label": "内容",

"name": "content",

"required": true

}

],

"actions": [

{

"label": "发送",

"type": "submit",

"primary": true

}

]

}

}

 

这个例子就是在 body 容器内，放置一个 form 类型的渲染器，它就成了一个简单的表单提交页面了，controls 中可以决定放哪些表单项目，actions 中可以放置操作按钮。

 

3.1.2.阿里飞饼

前言：

 

昨天技术总监告诉我个框架（Iceworks），又名飞冰，是阿里旗下的一个开发工具。也没说具体这个东西能解决什么问题。所以我最终的目的是为了知道这个框架有什么用，是干什么的。

 

引用飞冰官网的一句话：

 

每个后台相互独立，同类功能也需要重复开发，前期开发成本较高

 

技术方案差异大，人员变动后维护成本非常高

 

视觉质量参差不齐，使用效率大打折扣

 

……

 

我经过一下午的摸索和尝试，终于知道飞冰的核心是什么，核心在于区块。一个另类的插件。

 

飞冰技术要求：

 

1、前端中级工程师，初级无法理解和操作飞冰内部的复杂的模块组件等等，核心在于区块无法使用。

 

2、至少一个vue（react，angular）项目经验

 

区块：

 

问题1：为什么叫区块

 

问题2：区块是什么

 

问题3：区块干什么用的

 

1、组件：现在前端领域热门的组件化开发，也就是把页面当前公共部分抽离出来成为一个单独的模块，存在高度自定义特性。

 

我这里把组件和html当中的div，p，a等标签分为一类，组件就是这些东西，但是更加丰富，div，a，p标签称为原生组件，我们自己写的要自定义组件

 

组件化开发：框架提供的自定义组件功能，使得原本像bootstrop等插件变得不再完美，因为组件的最大特点，模块化，只在这里有效。

 

2、开发痛点：组件化开发仅仅是帮助我们把页面中最基础的东西抽离成为公共模块使用，但是我们在写页面的时候经常发生我需要写的十个页面有8个格式是一样的，都是头部按钮操作，中部数据展示，比如表格数据展示，最典型的，页面格式基本是头部一堆按钮，中部就是数据表格。

 

3、区块就是为了解决第二点提到的问题。

 

飞冰这里是自定义了一套区块开发规则，开发完成之后你上传到git和npm上面，然后当你需要使用的时候就直接把原本的代码内容直接下载到你本地项目，然后你再根据自己的需要进行个性化修改。

 

注意：

 

飞冰区块是直接把源代码变成文件模块成为单个文件夹下载到本地。然后你再自行引用（飞冰自己的模板不需要，但是也需要个性修改）

 

优点：1、重复页面格式固定，抽离成为固定页面模块

 

2、文件上传到git和npm保存，基本不存在丢失

 

3、页面格式可以预览，并且自定义，形成本公司体系的区块集合

 

4、使用的时候预览直接下载，再个性化页面

 

缺点：项目区块类似开源分享（那都不是事）

 

小项目感觉没什么必要，公司越大，越发现有用

 

最后：建议大家自己操作一下再说，飞冰的操作很简单，但是对于一般公司自成体系的，那么就很需要搭建自己的页面组合体系，飞冰是一个不错的选择。

 

文章更多的是讲了核心概念，不是入门操作，而且我也说了飞冰不适合初级前端。所以关于飞冰的操作大家看官网就行了。

 

吐槽下csdn中飞冰的博文，没一篇好用的。害得我只能自己摸索一下午才总结出飞冰的核心概念

 

3.1.3.easyui

 

今天来分享一个我前端技术-------如何使用Easy UI快速搭建一个后台，本博主也只是在官网文档学习了一个小时左右，就已经会使用了，当你学了Easy UI后，一个后台短短两分钟就可以over了，好了，别的不多说了，直接开始表演了；

下面这张图是效果图：

 

3.1.4 echart

在平时开发项目时，免不了需要对数据进行图表显示的需求，比如：趋势图、饼状图、柱形图等。自己身为一个PHPer，除了PHP本身的功能，不得不需要借助js来实现显示。在了解众多趋势图插件，国内外开源的项目，感觉还是来自百度团队研发的Echarts.js效果更好。本身是中文的项目，使用过程和显示效果更加适合使用。

#### 什么是Echarts.js?

Echarts.js是来自百度团队研发的图表js插件，利用HTML+js实现折线图、饼状图、热点图、3d图形等等，可在PC和移动端显示，加载速度快，功能丰富。

# Echart.js的趋势图入门与实例 

在平时开发项目时，免不了需要对数据进行图表显示的需求，比如：趋势图、饼状图、柱形图等。自己身为一个PHPer，除了PHP本身的功能，不得不需要借助js来实现显示。在了解众多趋势图插件，国内外开源的项目，感觉还是来自百度团队研发的Echarts.js效果更好。本身是中文的项目，使用过程和显示效果更加适合使用。

#### 什么是Echarts.js?

Echarts.js是来自百度团队研发的图表js插件，利用HTML+js实现折线图、饼状图、热点图、3d图形等等，可在PC和移动端显示，加载速度快，功能丰富。

![img](https:////upload-images.jianshu.io/upload_images/10987359-dcef0f72747972d8.png?imageMogr2/auto-orient/strip|imageView2/2/w/1029/format/webp)

image.png

我在多了解这个软件后，深深的被其功能所折服。在官方实例中，提供了十多种显示的方式，感人感觉最厉害的属于显示地球还有城市热点的功能。



![img](https:////upload-images.jianshu.io/upload_images/10987359-f044df914542489b.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

显示地球模型

官方提供的实例地址：http://echarts.baidu.com/examples/#chart-type-line

当然，这个功能在平时开发中很难需要用到，用到最多的还是折线图、饼状图之类的基础功能。

#### 折线图功能实现实例

先看一下展示效果，模仿某广告平台在某天的24小时的流量走势。



![img](https:////upload-images.jianshu.io/upload_images/10987359-69465f505d330256.png?imageMogr2/auto-orient/strip|imageView2/2/w/1104/format/webp)

image.png

### 实现步骤：

1、在页面中获取Echarts
 在官网中根据需要的版本http://echarts.baidu.com/download.html


![img](https:////upload-images.jianshu.io/upload_images/10987359-4f61854be371dadc.png?imageMogr2/auto-orient/strip|imageView2/2/w/871/format/webp)

image.png


 例如本例中实现的折线图，获取常用版或者精简版就够了。

2、引入Echarts

```xml
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <!-- 引入 ECharts 文件 -->
    <script src="echarts.min.js"></script>
</head>
</html>
```

3、为Echarts放置一个具备宽高的DOM容器

```xml
<div id="show_charts" style="width:100%; height:600px; margin:80px 0 80px 0;"></div>
```

4、Echarts加载数据

```kotlin
<script type="text/javascript">
/*此段js来自百度Echart.js插件*/
var dom = document.getElementById("show_charts");
var myChart = echarts.init(dom);
var app = {};
option = null;
option = {
    title : {
        text: '趋势图',
        subtext: '\r\n时间：2018-08-01\r\n\r\n广告类型：全部'
    },
    tooltip : {
        trigger: 'axis'
    },
    legend: {
        data:['请求','返回','展示','点击','成本支出']
    },
    toolbox: {
        show : true,
        feature : {
            mark : {show: true},
//            dataView : {show: true, readOnly: false},     //数据视图按钮
            magicType : {show: true, type: ['line', 'bar']},
//            restore : {show: true},       //图表右上角刷新按钮
            saveAsImage : {show: true}
        }
    },
    calculable : true,
    xAxis : [
        {
            type : 'category',
            boundaryGap : false,
            data: ["00:00~01:00","01:00~02:00","02:00~03:00","03:00~04:00","04:00~05:00","05:00~06:00","06:00~07:00","07:00~08:00","08:00~09:00","09:00~10:00","10:00~11:00","11:00~12:00","12:00~13:00","13:00~14:00","14:00~15:00","15:00~16:00","16:00~17:00","17:00~18:00","18:00~19:00","19:00~20:00","20:00~21:00","21:00~22:00","22:00~23:00","23:00~00:00"] }
    ],
    yAxis : [
        {
            type : 'value',
            axisLabel : {
                formatter: '{value}'
            }
        }
    ],
    series : [
        {
            name:'请求',
            type:'line',
            data:["162408","84274","51885","32385","29434","44453","113740","228128","344679","462128","585712","661449","704045","698178","642736","621051","614459","604958","615722","606564","721321","700773","519813","297617"]        },
        {
            name:'返回',
            type:'line',
            data:["152827","67202","37269","20956","18687","34066","103310","214873","327262","426414","524510","572305","600487","596252","544651","520815","509897","500239","501439","491926","577558","552850","401406","219789"]        },
        {
            name:'展示',
            type:'line',
            data:["115483","47313","26211","14156","12454","24095","74951","157273","237750","305293","373653","403249","423604","409693","367890","349129","343804","333511","333344","327859","391295","371397","265205","143960"]        },
        {
            name:'点击',
            type:'line',
            data:["4091","1735","959","632","664","1576","3996","7038","13033","14639","16757","17034","18368","17084","14718","14087","13928","13212","13042","13501","16424","15824","11331","6073"]        },
        {
            name:'成本支出',
            type:'line',
            data:[622.02,260.1,144.37,82.63,75.92,159.33,491.01,976.69,1494.82,1859.92,2215.17,2379.43,2569.69,2477.18,2220.92,2134.79,2094.97,2039.94,2021,2000.8,2325.55,2222.01,1590.13,859.93]        }
    ]
};
                    
;
if (option && typeof option === "object") {
    myChart.setOption(option, true);
}
</script>
```

经过代码设置，一个折线图是不是已经好了呢。没好的话，请检查Echarts.js文件的引用，此案例本人亲测过。这是一个折线图的功能，有很多参数需要我们在平时开发中去发现，大家可以多读读官方的教程，以及案例。[官网实例链接](http://echarts.baidu.com/examples/#chart-type-line)

好了，就介绍这些，希望此文章能对大家探索Echarts有所帮助。

# 浅谈单页应用和多页应用——Vue.js向

## 多页面

1. **多页面应用：每次页面跳转，后台都会返回一个新的HTML文档，就是多页面应用。**
2. 在以往传统开发的应用（网站）大多都是多页面应用，路由由后端来写。

> ![mpa](https://image-static.segmentfault.com/134/071/1340714692-5c871f636e043_articlex)

> 页面跳转=》返回HTML，优点：首屏时间快，SEO效果好，缺点是页面切换慢。

- 首屏时间快？访问页面，服务器只需要返回一个HTML文件，这个过程就经历了一个HTTP请求，请求响应回来，页面就能被展示出来。
- SEO（搜索引擎排名）效果好？搜索引擎能识别HTML的内容，根据内容进行排名。
- 页面切换慢：每一次切换页面都需要发起一个HTTP请求，假设网络较慢就会出现卡顿情况。

## 单页面

1. **单页应用：用vue写的项目是单页应用，刷新页面会请求一个HTML文件，切换页面的时候，并不会发起新的请求一个HTML文件，只是页面内容发生了变化**
2. vue.js原理：JS感知URL变化，当URL发生变化后，使用JS动态把当前的页面内容清除掉，再把下一个页面的内容挂载到页面上。此时的路由就不是后端来做了，而是前端来做，判断页面到底显示哪一个组件，再把以前的组件清除掉使用新的组件。就不会每一次跳转都请求HTML文件。

> ![spa](https://image-static.segmentfault.com/426/425/4264253619-5c87227d1743f_articlex)

> 页面跳转 =》 JS渲染，优点页面切换快，缺点首屏时间稍慢，SEO差

- 首屏时间慢？请求HTML还有JS的请求。（在此我想问：HTML里面不也有JS请求嘛？这一点是在看知乎上某个大神说的，没明白，但我觉得HTML里的JS大多是操作DOM的，因此跟HTML文件可以理解成一个请求。而vue.js则是负责整个应用的逻辑的，所以又得另算一个逻辑请求时延。）

- 页面切换快？页面跳转不需要去做HTML文件的请求，节约HTTP请求发送的时延。

- SEO差？搜索引擎只认识HTML内容不认识JS内容。单页应用的渲染都是靠JavaScript渲染出来的。搜索引擎不好识别排名。

  

### 有上面这么多的问题，为什么当下的前端开发中还要使用VUE开发单页应用？

- **vue中还有服务器端渲染的解决方案，完美解决上述问题。**

总结如下：

  单页面应用指一个系统只加载一次资源，然后下面的操作交互、数据交互是通过router、ajax来进       行，页面并没有刷新；
<1>在vue搭建的环境里面怎么有没有公用的css和js?如果有是怎么引用的？

      有公用的css和js，有两种引用的方法：（要深刻理解单页面应用程序哦，单页面就是引入后在哪里都能使用）
    
      1.全局公共引用样式和js文件


​       

   2.组件的引入

 

  单页面的应用优点：

  1.分离前后端关注点，前端负责界面显示，后端负责数据存储和计算。不会把前后端的逻辑混杂在一起；

  2.减轻服务器压力，服务器只用出数据就可以；

  3.同一套后端程序代码，不用修改就可以用于Web界面、手机、平板等多种客户端；

  4.用户体验好、快，内容的改变不需要重新加载整个页面，web应用更具响应性和更令人着迷；

  5.SPA和RESTful架构一起使用，后端不再负责模板渲染、输出页面工作，web前端和各种移动终端地位对等，后端API通用化；

  

单页面的应用缺点：

1.初次加载耗时相对增多；
2.导航不可用，如果一定要导航需要自行实现前进、后退，需要程序来实现管理；
3.使用脚本修改页面，这个脚本我们都知道，他的兼容性是个大问题；
4. 不利于SEO问题，现在可以通过Prerender等技术解决一部分；
————————————————
版权声明：本文为CSDN博主「歪歪100」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_41646716/article/details/80073995